
options:
    chunkTimeout: 2

import:
    org.bukkit.inventory.InventoryHolder

# Called when an inventory slot loads
event "slotLoad":
    patterns:
        [on] [inv[entory]] (item|slot) load[ed]
    event-values: item, inventory, integer, string

#on slot load:
#    set {_id} to getId(event-item)
#    actionbar("&3%{_id}% loaded")

#on entity add to world:
#    event-entity is a dropped item
#    set {_id} to getId(item of event-entity)
#    actionbar("&6%{_id}% loaded")

local function callEvent(item:item, inv:inventory, slot:integer, source:string=""):
    if {_item} isn't set:
        if {_source} is "player join":
            {_slot} >= 36
            {_slot} <= 39
            exit 2 sections
        log error "Item unset when calling for slot %{_slot}% of %{_inv}%"
        exit trigger
    {_item} isn't air
    set {_event-values::item} to {_item}
    set {_event-values::inventory} to {_inv}
    set {_event-values::integer} to {_slot}
    set {_event-values::text} to {_source}
    call custom event "slotLoad" using event-values {_event-values::*}

function loadChunkSlots(chunk:chunk):
    set {_start} to now
    set {_totalslots} to 0
    set {_blocks::*} to (...{_chunk}.getTileEntities(true)) where [inventory of input is set]
    set {_entities::*} to ((...{_chunk}.getEntities()) where [input is an instance of InventoryHolder]) where [input isn't a player]
    loop {_blocks::*}:
        set {_inv} to inventory of loop-value
        loop (amount of slots of {_inv}) times:
            set {_slot} to (loop-value-2) - 1
            set {_item} to (slot {_slot} of {_inv})
            callEvent({_item}, {_inv}, {_slot}, "load chunk block")
        if seconds of (time since {_start}) > {@chunkTimeout}:
            log error "%{_chunk}% took too long to load slots (%(chunk x of {_chunk})*16% ~ %(chunk z of {_chunk})*16%)"
            exit trigger
    loop {_entities::*}:
        set {_inv} to loop-value.getInventory()
        loop (amount of slots of {_inv}) times:
            set {_slot} to (loop-value-2) - 1
            set {_item} to (slot {_slot} of {_inv})
            callEvent({_item}, {_inv}, {_slot}, "load chunk entity")
        if seconds of (time since {_start}) > {@chunkTimeout}:
            log error "%{_chunk}% took too long to load slots (%(chunk x of {_chunk})*16% ~ %(chunk z of {_chunk})*16%)"
            exit trigger

# chunk loading
on chunk load:
    loadChunkSlots(event-chunk)

# player joining
on join:
    loop (amount of slots of player's inventory) times:
        set {_item} to (slot (loop-value)-1 of player's inventory)
        callEvent({_item}, player's inventory, (loop-value)-1, "player join")

# creative inv, /give etc
on inventory slot change:
    gamemode of player isn't creative # messes with cursor slot in creative
    set {_slot} to index of event-slot
    callEvent(event-item, player's inventory, {_slot}, "slot change")

###
# crafting
on preparing craft:
    callEvent(event-item, event-inventory, 0, "crafting")

# smelting
#on smelt:
#    set {_inv} to inventory of event-block
#    callEvent(slot 2 of {_inv}, {_inv}, 2, "smelting")

# hoppers
on inventory pickup:
    loop (amount of slots of event-inventory) times:
        set {_item} to (slot loop-value of event-inventory)
        callEvent({_item}, event-inventory, loop-value, "hopper from dropped")

# hoppers, droppers
on inventory item move:
    # from block
    #loop (amount of slots of event-inventory) times:
    #    set {_slot} to (loop-value) - 1
    #    set {_item} to (slot {_slot} of event-inventory)
    #    callEvent({_item}, event-inventory, {_slot})
    # to block
    set {_inv} to inventory of future event-block
    loop (amount of slots of {_inv}) times:
        set {_slot} to (loop-value) - 1
        set {_item} to (slot {_slot} of {_inv})
        callEvent({_item}, {_inv}, {_slot}, "hopper/dropper")
###

on book edit:
    set {_slot} to 40 if event.getSlot() is -1 else event.getSlot()
    callEvent(event-item, player's inventory, {_slot}, "book edit")

